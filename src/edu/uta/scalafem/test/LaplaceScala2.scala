package edu.uta.scalafem.test

import edu.uta.futureye.core.NodeType
import edu.uta.futureye.function.intf.Function
import edu.uta.futureye.lib.element.FELinearTriangle
import edu.uta.futureye.lib.weakform.WeakFormLaplace2D
import edu.uta.futureye.lib.assembler.AssemblerScalar
import edu.uta.futureye.algebra.solver.external.SolverJBLAS
import edu.uta.futureye.core.Element
import edu.uta.futureye.algebra.intf.SparseVector
import edu.uta.futureye.lib.weakform.WeakFormBuilder
import edu.uta.futureye.lib.weakform.WeakFormBuilder.Type
import edu.uta.futureye.core.NodeType
import edu.uta.futureye.util.Constant
import edu.uta.scalafem.core.Mesh
import edu.uta.scalafem.util.container.ElementList
import edu.uta.scalafem.function.operator.FMath._
import edu.uta.scalafem.function.MathFun
import edu.uta.scalafem.weakform.PDE
import edu.uta.scalafem.weakform.HandSide._
import edu.uta.scalafem.weakform.DomainType._
import edu.uta.scalafem.io.MeshWriter
import edu.uta.scalafem.io.MeshReader
import scala.collection.immutable.HashMap


/**
 * <blockquote><pre>
 * Problem:
 *   -k*\Delta{u} + c*u*v = f in \Omega
 *   u=0,                     on \Gamma_D
 *   d*u + k*u_n = q          on \Gamma_R
 * where
 *   u = u(x,y)
 *   \Omega = [-3,3]*[-3,3]
 *   \Gamma_R = Right boundary of \Omega (Robin)
 *   \Gamma_D = Other boundary of \Omega (Dirichlet)
 *   k = 1.0
 *   c = sqrt(x^2+y^2)
 *   f = -2.0*(x^2+y^2)+36.0
 *   d = 1.0
 *   q = 1.0
 * </blockquote></pre>
 * 
 * @author liuyueming
 */
object LaplaceScala2 {
	def run() {
	    //1.Read in a triangle mesh from an input file with
	    //  format ASCII UCD generated by Gridgen
	    val mesh = MeshReader("triangle.grd") read2DMesh
	    
	    //Compute geometry relationship of nodes and elements
	    mesh computeNodeBelongsToElements
	    
	    //2.Mark border types
	    val map = HashMap[NodeType, MathFun](
			NodeType.Dirichlet -> null,
			NodeType.Robin   -> MathFun("x","y") {
				 v => if(3.0-v("x")<Constant.eps) 1.0 else -1.0 
			  }
			)
	    mesh.markBorderNode(map)
	
	    //3.Use element library to assign degrees of
	    //  freedom (DOF) to element
	    val feLT = new FELinearTriangle()
	    mesh.elements foreach feLT.assignTo _
	    
	    //4.Weak form
	    val eq1 = new PDE
	    val k = C1
	    val c = sqrt(X*X + Y*Y)
	    val f = -2.0*(X*X + Y*Y) + 36.0
	    val d = C1
	    val q = C1
	    eq1.integrate(LHS, Inner) {
	    	(u,v) => (grad(u, "x","y") dot grad(v, "x","y")) + c*u*v 
	    }.integrate(LHS, Border) {
	    	(u,v) => d*u*v
	    }.integrate(RHS, Inner) {
	    	(u,v) => f*v
	    }.integrate(RHS, Border) {
	    	(u,v) => q*v
	    }
 	    
	    //5.Assembly process
	    val assembler = new AssemblerScalar(mesh, eq1.getWeakForm)
	    assembler assemble
	    val stiff = assembler getStiffnessMatrix
	    val load = assembler getLoadVector
	    
	    //Boundary condition
	    assembler imposeDirichletCondition C0
	
	    //6.Solve linear system
	    val solver = new SolverJBLAS()
	    val u = solver solveDGESV(stiff, load)
	    println("u=");
	    for{i <- 1 to u.getDim()} yield{ println("%.3f".format(u(i))) } //28.017
	    
	    //7.Output results to an Techplot format file
	    MeshWriter(mesh) writeTechplot("./tutorial/Laplace2D.dat", u);
	}
	
	def main(args: Array[String]): Unit = {
		run
	}
}
