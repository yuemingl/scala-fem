ScalaFEM provides warpper classes for project <a href='http://code.google.com/p/futureye/'>FuturEye</a>. Mathematical-look expressions for functions and weak forms can be used in ScalaFEM. For example: If we have function f1 = x^2 + 2(x + 1) then
```
//Java code in FuturEye
Function f1 = X.M(X).A( X.A(1.0).M(2.0) );
System.out.println(f1);
System.out.println(f1.value(new Variable(2.0)));
System.out.println(f1._d("x")); //derivative of f1
System.out.println(f1._d("x").value(new Variable(3.0)));
//Output
x * x + (x + 1.0) * 2.0
10.0
x + x + 2.0
8.0

//Scala code in ScalaFEM
var f1 = X*X + 2.0*(X + 1.0)
println(f1)
println(f1(2.0))
println(f1("x",2.0))
println(f1._d("x")) //derivative of f1
println(f1._d("x")(3.0))
//Output
x * x + 2.0 * (x + 1.0)
10.0
10.0
x + x + 2.0
8.0
```
Did you see the difference at the first line of output?

Compare the following code segment with <a href='http://code.google.com/p/futureye/wiki/Build_yourself_weakforms'>2D_Laplace</a> in FururEye
```
/**
 * <blockquote><pre>
 * Problem:
 *   -k*\Delta{u} + c*u*v = f in \Omega
 *   u=0,                     on \Gamma_D
 *   d*u + k*u_n = q          on \Gamma_R
 * where
 *   u = u(x,y)
 *   \Omega = [-3,3]*[-3,3]
 *   \Gamma_R = Right boundary of \Omega (Robin)
 *   \Gamma_D = Other boundary of \Omega (Dirichlet)
 *   k = 1.0
 *   c = sqrt(x^2+y^2)
 *   f = -2.0*(x^2+y^2)+36.0
 *   d = 1.0
 *   q = 1.0
 * </blockquote></pre>
 * 
 * @author liuyueming
 */
object LaplaceScala2 {
	def run() {
	    //1.Read in a triangle mesh from an input file with
	    //  format ASCII UCD generated by Gridgen
	    val mesh = MeshReader("triangle.grd") read2DMesh
	    
	    //Compute geometry relationship of nodes and elements
	    mesh computeNodeBelongsToElements
	    
	    //2.Mark border types
	    val map = HashMap[NodeType, MathFun](
			NodeType.Dirichlet -> null,
			NodeType.Robin   -> MathFun("x","y") {
				 v => if(3.0-v("x")<Constant.eps) 1.0 else -1.0 
			  }
			)
	    mesh.markBorderNode(map)

	    //3.Use element library to assign degrees of
	    //  freedom (DOF) to element
	    val feLT = new FELinearTriangle()
	    mesh.elements foreach feLT.assignTo _
	    
	    //4.Weak form
	    val eq1 = new PDE
	    val k = C1
	    val c = sqrt(X*X + Y*Y)
	    val f = -2.0*(X*X + Y*Y) + 36.0
	    val d = C1
	    val q = C1
	    eq1.integrate(LHS, Inner) {
		(u,v) => (grad(u, "x","y") dot grad(v, "x","y")) + c*u*v 
	    }.integrate(LHS, Border) {
		(u,v) => d*u*v
	    }.integrate(RHS, Inner) {
		(u,v) => f*v
	    }.integrate(RHS, Border) {
		(u,v) => q*v
	    }
	    
	    //5.Assembly process
	    val assembler = new AssemblerScalar(mesh, eq1.getWeakForm)
	    assembler assemble
	    val stiff = assembler getStiffnessMatrix
	    val load = assembler getLoadVector
	    
	    //Boundary condition
	    assembler imposeDirichletCondition C0

	    //6.Solve linear system
	    val solver = new SolverJBLAS()
	    val u = solver solveDGESV(stiff, load)
	    println("u=");
	    for{i <- 1 to u.getDim()} yield{ println("%.3f".format(u(i))) } //28.017
	    
	    //7.Output results to an Techplot format file
	    MeshWriter(mesh) writeTechplot("./tutorial/Laplace2D.dat", u);
	}

	def main(args: Array[String]): Unit = {
		run
	}
}
```